#+SETUPFILE: ~/org-themes/src/solarized_dark/solarized_dark.theme

* 为什么要学elisp

  希望将emacs作为终生使用的编辑器

  希望能写出有意义的东西回馈社区


* 一个简单的二分

#+BEGIN_SRC emacs-lisp
  (setq a [0 1 2 3 5 5 6 7 8 8 9 9 9 10 12 16 17])

  (defun bsearch (a l r target)
	(let ((mid (/ (+ l r) 2)))
	  (cond ((>= l r) l)
		((<= target (aref a mid)) (bsearch a l mid target))
		(t (bsearch a (+ 1 mid) r target)))))

  (bsearch a 0 (- (length a) 1) 8)
#+END_SRC

#+RESULTS:
: 8


#+BEGIN_SRC python :results output
  a = [0, 1, 2, 3, 5, 5, 6, 7, 8, 8, 9, 9, 9, 10, 12, 16, 17]


  def bsearch(a, l, r, target):
	  if l >= r:
		  return l
	  mid = (l + r) // 2
	  if target <= mid:
		  return bsearch(a, l, mid, target)
	  else:
		  return bsearch(a, mid+1, r, target)


  print(bsearch(a, 0, len(a)-1, 8))
#+END_SRC

#+RESULTS:
: 8

#+BEGIN_SRC go
  package main
  import ("fmt")

  func main() {
	  a := []int{0, 1, 2, 3, 5, 5, 6, 7, 8, 8, 9, 9, 9, 10, 12, 16, 17}
	  fmt.Println(bsearch(a, 0, len(a) - 1, 8))
  }


  func bsearch(a []int, l, r int,  target int) int {
	  if l >= r {
		  return l
	  }
	  mid := (l + r) / 2
	  if target <= mid {
		  return bsearch(a, l , mid, target)
	  } else {
		  return bsearch(a, mid+1, r, target)
	  }
  }

#+END_SRC

#+RESULTS:
: 8

#+BEGIN_SRC C++
  #include <iostream>

  using namespace std;

  int bsearch(int a[], int l, int r, int target) {
		if (l >= r) return l;
		int mid = l+r >> 1;
		if (target <= mid) return bsearch(a, l, mid, target);
		else return bsearch(a, mid+1, r, target);
  }

  int main() {
		int a[] = {0, 1, 2, 3, 5, 5, 6, 7, 8, 8, 9, 9, 9, 10, 12, 16, 17};
		cout <<  bsearch(a, 0, sizeof(a)/sizeof(a[0]) - 1, 8) << endl;
  }
#+END_SRC

#+RESULTS:
: 8


* 见识一下org-babel的神奇魔法

其实org-babel + shell在一定程度上和ansible比较类似, 但这个更偏向于文档

有的header只针对部分语言有效, 例如:stdin好像只对shell有效

  #+NAME: vallian-table
| 1 |
| 2 |
| 3 |
| 4 |
| 5 |


#+NAME: my-table
| A | 1 |
| B | 2 |
| C | 3 |


#+NAME: literal-example
#+BEGIN_EXAMPLE 
A literal example
on two lines
#+END_EXAMPLE

#+BEGIN_SRC emacs-lisp  :var lst=vallian-table[2:4] :exports both
(print lst)
#+END_SRC

#+RESULTS:
| 3 |
| 4 |
| 5 |

#+NAME: where-am-i
#+BEGIN_SRC python :results output :dir /tmp :exports both
import os
print (os.getcwd())
#+END_SRC

#+RESULTS: where-am-i
: /tmp


#+BEGIN_SRC C++  :exports both
  #include <iostream>

  using namespace std;

  int main() {
	cout << "hello" << endl;
  }

#+END_SRC

#+RESULTS:
: hello


#+BEGIN_SRC python :var lt=literal-example :exports both
  return lt.split("\n")
#+END_SRC

#+RESULTS:
| A literal example | \ton two lines | \t |


#+BEGIN_SRC python :results value raw :exports both
return [(1, 2), (2, 3)]
#+END_SRC

#+RESULTS:
[(1, 2), (2, 3)]

#+NAME: my-dict
#+BEGIN_SRC python :results value raw :exports both
  return {'a':1, 'b':2}
#+END_SRC

#+RESULTS:
{'a': 1, 'b': 2}

#+BEGIN_SRC python :var dct=my-dict :results value raw :exports both
return dct
#+END_SRC

#+RESULTS:
{'a': 1, 'b': 2}
{'a': 1, 'b': 2}
{'a': 1, 'b': 2}

#+BEGIN_SRC shell :stdin literal-example :results output :exports both
v=$(cat)
echo $v
#+END_SRC

#+RESULTS:
: A literal example on two lines

#+BEGIN_SRC dot :file imgs/test-dot.svg :exports both
  digraph G {
	  a -> b
  }
#+END_SRC

#+RESULTS:
[[file:imgs/test-dot.png]]


